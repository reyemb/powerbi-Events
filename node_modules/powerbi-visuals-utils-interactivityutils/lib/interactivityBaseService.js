export var FilterAction;
(function (FilterAction) {
    FilterAction[FilterAction["merge"] = 0] = "merge";
    FilterAction[FilterAction["remove"] = 1] = "remove";
})(FilterAction || (FilterAction = {}));
/**
* Creates a clear an svg rect to catch clear clicks.
*/
export function appendClearCatcher(selection) {
    return selection
        .append("rect")
        .classed("clearCatcher", true)
        .attr("width", "100%")
        .attr("height", "100%");
}
export function dataHasSelection(data) {
    for (let i = 0, ilen = data.length; i < ilen; i++) {
        if (data[i].selected) {
            return true;
        }
    }
    return false;
}
export class InteractivityBaseService {
    constructor() {
        // References
        /* eslint-disable @typescript-eslint/no-empty-function */
        this.renderSelectionInVisual = () => { };
        this.renderSelectionInLegend = () => { };
        this.renderSelectionInLabels = () => { };
        /* eslint-enable @typescript-eslint/no-empty-function */
        // Selection state
        this.isInvertedSelectionMode = false;
    }
    // IInteractivityService Implementation
    //  Binds the visual to the interactivityService
    bind(options) {
        // Bind the data
        if (options.interactivityServiceOptions && options.interactivityServiceOptions.overrideSelectionFromData) {
            // Override selection state from data points if needed
            this.takeSelectionStateFromDataPoints(options.dataPoints);
        }
        if (options.interactivityServiceOptions) {
            if (options.interactivityServiceOptions.isLegend) {
                // Bind to legend data instead of normal data if isLegend
                this.selectableLegendDataPoints = options.dataPoints;
                this.renderSelectionInLegend = () => options.behavior.renderSelection(this.legendHasSelection());
            }
            else if (options.interactivityServiceOptions.isLabels) {
                // Bind to label data instead of normal data if isLabels
                this.selectableLabelsDataPoints = options.dataPoints;
                this.renderSelectionInLabels = () => options.behavior.renderSelection(this.labelsHasSelection());
            }
            else {
                this.selectableDataPoints = options.dataPoints;
                this.renderSelectionInVisual = () => options.behavior.renderSelection(this.hasSelection());
            }
        }
        else {
            this.selectableDataPoints = options.dataPoints;
            this.renderSelectionInVisual = () => options.behavior.renderSelection(this.hasSelection());
        }
        options.behavior.bindEvents(options, this);
        // Sync data points with current selection state
        this.syncSelectionState();
    }
    /**
     * Sets the selected state of all selectable data points to false and invokes the behavior's select command.
     */
    clearSelection() {
        this.applyToAllSelectableDataPoints((dataPoint) => dataPoint.selected = false);
        this.renderAll();
    }
    legendHasSelection() {
        return this.selectableLegendDataPoints ? dataHasSelection(this.selectableLegendDataPoints) : false;
    }
    labelsHasSelection() {
        return this.selectableLabelsDataPoints ? dataHasSelection(this.selectableLabelsDataPoints) : false;
    }
    isSelectionModeInverted() {
        return this.isInvertedSelectionMode;
    }
    handleSelection(dataPoints, multiSelect) {
        if (!dataPoints) {
            return;
        }
        this.select(dataPoints, multiSelect);
        this.sendSelectionToHost();
        this.renderAll();
    }
    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
    handleContextMenu(dataPoint, point) {
        // don't need to handle context menu here.
        // see InteractivitySelectionService class
        return;
    }
    handleClearSelection() {
        this.clearSelection();
        this.sendSelectionToHost();
    }
    renderAll() {
        this.renderSelectionInVisual();
        this.renderSelectionInLegend();
        this.renderSelectionInLabels();
    }
    applyToAllSelectableDataPoints(action) {
        const selectableDataPoints = this.selectableDataPoints;
        const selectableLegendDataPoints = this.selectableLegendDataPoints;
        const selectableLabelsDataPoints = this.selectableLabelsDataPoints;
        if (selectableDataPoints) {
            for (const dataPoint of selectableDataPoints) {
                action(dataPoint);
            }
        }
        if (selectableLegendDataPoints) {
            for (const dataPoint of selectableLegendDataPoints) {
                action(dataPoint);
            }
        }
        if (selectableLabelsDataPoints) {
            for (const dataPoint of selectableLabelsDataPoints) {
                action(dataPoint);
            }
        }
    }
}
//# sourceMappingURL=interactivityBaseService.js.map