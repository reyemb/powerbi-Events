import powerbi from "powerbi-visuals-api";
import { Selection } from "d3-selection";
export interface BaseDataPoint {
    selected: boolean;
}
export declare enum FilterAction {
    merge = 0,
    remove = 1
}
/**
* Creates a clear an svg rect to catch clear clicks.
*/
export declare function appendClearCatcher(selection: Selection<any, any, any, any>): Selection<any, any, any, any>;
export declare function dataHasSelection(data: BaseDataPoint[]): boolean;
export interface IInteractiveBehavior {
    bindEvents(behaviorOptions: IBehaviorOptions<BaseDataPoint>, selectionHandler: ISelectionHandler): void;
    renderSelection(hasSelection: boolean): void;
}
/**
 * An optional options bag for binding to the interactivityService
 */
export interface InteractivityServiceOptions {
    isLegend?: boolean;
    isLabels?: boolean;
    overrideSelectionFromData?: boolean;
}
/**
 * Responsible for managing interactivity between the hosting visual and its peers
 */
export interface IInteractivityService<SelectableDataPointType extends BaseDataPoint> {
    bind(options: IBehaviorOptions<SelectableDataPointType>): void;
    clearSelection(): void;
    applySelectionStateToData(dataPoints: SelectableDataPointType[], hasHighlights?: boolean): boolean;
    hasSelection(): boolean;
    legendHasSelection(): boolean;
    isSelectionModeInverted(): boolean;
}
export interface ISelectionHandler {
    /**
     * Handles a selection event by selecting the given data point.  If the data point's
     * identity is undefined, the selection state is cleared. In this case, if specificIdentity
     * exists, it will still be sent to the host.
     */
    handleSelection(dataPoints: BaseDataPoint | BaseDataPoint[], multiSelect: boolean): void;
    handleClearSelection(): void;
    handleContextMenu(dataPoint: BaseDataPoint, point: powerbi.extensibility.IPoint): void;
}
export interface IBehaviorOptions<SelectableDataPointType extends BaseDataPoint> {
    behavior: IInteractiveBehavior;
    dataPoints: SelectableDataPointType[];
    interactivityServiceOptions?: InteractivityServiceOptions;
}
export declare abstract class InteractivityBaseService<SelectableDataPointType extends BaseDataPoint, IBehaviorOptionsType extends IBehaviorOptions<SelectableDataPointType>> implements IInteractivityService<SelectableDataPointType>, ISelectionHandler {
    protected renderSelectionInVisual: () => void;
    protected renderSelectionInLegend: () => void;
    protected renderSelectionInLabels: () => void;
    protected isInvertedSelectionMode: boolean;
    selectableDataPoints: SelectableDataPointType[];
    selectableLegendDataPoints: SelectableDataPointType[];
    selectableLabelsDataPoints: SelectableDataPointType[];
    bind(options: IBehaviorOptionsType): void;
    abstract applySelectionStateToData(dataPoints: SelectableDataPointType[], hasHighlights?: boolean): boolean;
    /**
     * Checks whether there is at least one item selected.
     */
    abstract hasSelection(): boolean;
    /**
     * Syncs the selection state for all data points that have the same category. Returns
     * true if the selection state was out of sync and corrections were made; false if
     * the data is already in sync with the service.
     *
     * If the data is not compatible with the current service's current selection state,
     * the state is cleared and the cleared selection is sent to the host.
     *
     * Ignores series for now, since we don't support series selection at the moment.
     */
    abstract syncSelectionState(): void;
    /**
     * Sets the selected state of all selectable data points to false and invokes the behavior's select command.
     */
    clearSelection(): void;
    legendHasSelection(): boolean;
    labelsHasSelection(): boolean;
    isSelectionModeInverted(): boolean;
    handleSelection(dataPoints: SelectableDataPointType | SelectableDataPointType[], multiSelect: boolean): void;
    handleContextMenu(dataPoint: SelectableDataPointType, point: powerbi.extensibility.IPoint): void;
    handleClearSelection(): void;
    protected abstract select(dataPoints: SelectableDataPointType | SelectableDataPointType[], multiSelect: boolean): void;
    protected abstract takeSelectionStateFromDataPoints(dataPoints: SelectableDataPointType[]): void;
    protected abstract sendSelectionToHost(): void;
    protected renderAll(): void;
    protected applyToAllSelectableDataPoints(action: (selectableDataPoint: SelectableDataPointType) => void): void;
}
