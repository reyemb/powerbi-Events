import { arrayExtensions } from "powerbi-visuals-utils-typeutils";
/**
 * Factory method to create an IInteractivityService instance.
 */
export function createInteractivityService(hostServices) {
    return new InteractivityService(hostServices);
}
/**
* Creates a clear an svg rect to catch clear clicks.
*/
export function appendClearCatcher(selection) {
    return selection
        .append("rect")
        .classed("clearCatcher", true)
        .attr("width", "100%")
        .attr("height", "100%");
}
export function dataHasSelection(data) {
    for (let i = 0, ilen = data.length; i < ilen; i++) {
        if (data[i].selected)
            return true;
    }
    return false;
}
// It's a temporary function for compatibility with API 2.1
// It will probably be removed after API 2.2 release
export function checkDatapointAgainstSelectedIds(dataPoint, selectedIds) {
    return selectedIds.some((selectionId) => {
        const measuredSelectionId = selectionId;
        const otherSelectionId = dataPoint.identity;
        // if the first selectionId is built only from measures then compare measures
        if (!measuredSelectionId.dataMap && measuredSelectionId.compareMeasures(measuredSelectionId.measures, otherSelectionId.measures)) {
            return true;
        }
        const selectorOne = measuredSelectionId.getSelector();
        const selectorTwo = otherSelectionId.getSelector();
        // if the first or the second selectionId doesn't have data then return false
        if (!selectorOne.data || !selectorTwo.data) {
            return false;
        }
        // At this point both CVSelectionId's got data, we see if the first selectionId data is a subset of the second selectionId data, if not return false
        for (const dataRepition of selectorOne.data) {
            if (!selectorTwo.data.some(dataI => JSON.stringify(dataI) === JSON.stringify(dataRepition))) {
                return false;
            }
        }
        return true;
    });
}
export class InteractivityService {
    constructor(hostServices) {
        // References
        /* eslint-disable @typescript-eslint/no-empty-function */
        this.renderSelectionInVisual = () => { };
        this.renderSelectionInLegend = () => { };
        this.renderSelectionInLabels = () => { };
        /* eslint-enable @typescript-eslint/no-empty-function */
        // Selection state
        this.selectedIds = [];
        this.isInvertedSelectionMode = false;
        this.selectionManager = hostServices.createSelectionManager();
        if (this.selectionManager.registerOnSelectCallback) {
            this.selectionManager.registerOnSelectCallback(() => {
                this.restoreSelection([...this.selectionManager.getSelectionIds()]);
            });
        }
    }
    // IInteractivityService Implementation
    /** Binds the visual to the interactivityService */
    bind(dataPoints, behavior, behaviorOptions, options) {
        // Bind the data
        if (options && options.overrideSelectionFromData) {
            // Override selection state from data points if needed
            this.takeSelectionStateFromDataPoints(dataPoints);
        }
        if (options) {
            if (options.isLegend) {
                // Bind to legend data instead of normal data if isLegend
                this.selectableLegendDataPoints = dataPoints;
                this.renderSelectionInLegend = () => behavior.renderSelection(this.legendHasSelection());
            }
            else if (options.isLabels) {
                // Bind to label data instead of normal data if isLabels
                this.selectableLabelsDataPoints = dataPoints;
                this.renderSelectionInLabels = () => behavior.renderSelection(this.labelsHasSelection());
            }
            else {
                this.selectableDataPoints = dataPoints;
                this.renderSelectionInVisual = () => behavior.renderSelection(this.hasSelection());
            }
        }
        else {
            this.selectableDataPoints = dataPoints;
            this.renderSelectionInVisual = () => behavior.renderSelection(this.hasSelection());
        }
        behavior.bindEvents(behaviorOptions, this);
        // Sync data points with current selection state
        this.syncSelectionState();
    }
    clearSelectedIds() {
        arrayExtensions.clear(this.selectedIds);
    }
    /**
     * Sets the selected state of all selectable data points to false and invokes the behavior's select command.
     */
    clearSelection() {
        this.clearSelectedIds();
        this.applyToAllSelectableDataPoints((dataPoint) => dataPoint.selected = false);
        this.renderAll();
    }
    applySelectionStateToData(dataPoints, hasHighlights) {
        if (hasHighlights && this.hasSelection()) {
            const selectionIds = (this.selectionManager.getSelectionIds() || []);
            arrayExtensions.clear(this.selectedIds);
            arrayExtensions.clear(selectionIds);
        }
        for (const dataPoint of dataPoints) {
            dataPoint.selected = checkDatapointAgainstSelectedIds(dataPoint, this.selectedIds);
        }
        return this.hasSelection();
    }
    /**
     * Apply new selections to change internal state of interactivity service
     */
    restoreSelection(selectionIds) {
        this.clearSelection();
        this.selectedIds = selectionIds;
        this.syncSelectionState();
        this.renderAll();
    }
    /**
     * Checks whether there is at least one item selected.
     */
    hasSelection() {
        return this.selectedIds.length > 0;
    }
    legendHasSelection() {
        return this.selectableLegendDataPoints ? dataHasSelection(this.selectableLegendDataPoints) : false;
    }
    labelsHasSelection() {
        return this.selectableLabelsDataPoints ? dataHasSelection(this.selectableLabelsDataPoints) : false;
    }
    isSelectionModeInverted() {
        return this.isInvertedSelectionMode;
    }
    // ISelectionHandler Implementation
    applySelectionFilter() {
        if (!this.selectionManager) {
            return;
        }
        if (typeof this.selectionManager.applySelectionFilter !== "undefined") {
            this.selectionManager.applySelectionFilter();
        }
    }
    handleSelection(dataPoints, multiSelect) {
        // defect 7067397: should not happen so assert but also don't continue as it's
        // causing a lot of error telemetry in desktop.
        if (!dataPoints) {
            return;
        }
        this.select(dataPoints, multiSelect);
        this.sendSelectionToHost(multiSelect);
        this.renderAll();
    }
    handleClearSelection() {
        this.clearSelection();
        this.sendSelectionToHost(false);
    }
    /**
     * Syncs the selection state for all data points that have the same category. Returns
     * true if the selection state was out of sync and corrections were made; false if
     * the data is already in sync with the service.
     *
     * If the data is not compatible with the current service's current selection state,
     * the state is cleared and the cleared selection is sent to the host.
     *
     * Ignores series for now, since we don't support series selection at the moment.
     */
    syncSelectionState() {
        if (this.isInvertedSelectionMode) {
            return this.syncSelectionStateInverted();
        }
        if (!this.selectableDataPoints && !this.selectableLegendDataPoints) {
            return;
        }
        if (this.selectableDataPoints) {
            InteractivityService.updateSelectableDataPointsBySelectedIds(this.selectableDataPoints, this.selectedIds);
        }
        if (this.selectableLegendDataPoints) {
            InteractivityService.updateSelectableDataPointsBySelectedIds(this.selectableLegendDataPoints, this.selectedIds);
        }
        if (this.selectableLabelsDataPoints) {
            for (const labelsDataPoint of this.selectableLabelsDataPoints) {
                labelsDataPoint.selected = this.selectedIds.some((value) => {
                    return value.includes(labelsDataPoint.identity);
                });
            }
        }
    }
    syncSelectionStateInverted() {
        const selectedIds = this.selectedIds;
        const selectableDataPoints = this.selectableDataPoints;
        if (!selectableDataPoints)
            return;
        if (selectedIds.length === 0) {
            for (const dataPoint of selectableDataPoints) {
                dataPoint.selected = false;
            }
        }
        else {
            for (const dataPoint of selectableDataPoints) {
                if (selectedIds.some((value) => value.includes(dataPoint.identity))) {
                    dataPoint.selected = true;
                }
                else if (dataPoint.selected) {
                    dataPoint.selected = false;
                }
            }
        }
    }
    // Private utility methods
    renderAll() {
        this.renderSelectionInVisual();
        this.renderSelectionInLegend();
        this.renderSelectionInLabels();
    }
    /** Marks a data point as selected and syncs selection with the host. */
    select(dataPoints, multiSelect) {
        const selectableDataPoints = [].concat(dataPoints);
        const originalSelectedIds = [...this.selectedIds];
        if (!multiSelect || !selectableDataPoints.length) {
            this.clearSelectedIds();
        }
        selectableDataPoints.forEach((dataPoint) => {
            const shouldDataPointBeSelected = !checkDatapointAgainstSelectedIds(dataPoint, originalSelectedIds);
            this.selectSingleDataPoint(dataPoint, shouldDataPointBeSelected);
        });
        this.syncSelectionState();
    }
    selectSingleDataPoint(dataPoint, shouldDataPointBeSelected) {
        if (!dataPoint || !dataPoint.identity) {
            return;
        }
        const identity = dataPoint.identity;
        if (shouldDataPointBeSelected) {
            dataPoint.selected = true;
            this.selectedIds.push(identity);
            if (identity.hasIdentity()) {
                this.removeSelectionIdsWithOnlyMeasures();
            }
            else {
                this.removeSelectionIdsExceptOnlyMeasures();
            }
        }
        else {
            dataPoint.selected = false;
            this.removeId(identity);
        }
    }
    removeId(toRemove) {
        const selectedIds = this.selectedIds;
        for (let i = selectedIds.length - 1; i > -1; i--) {
            const currentId = selectedIds[i];
            if (toRemove.includes(currentId))
                selectedIds.splice(i, 1);
        }
    }
    sendSelectionToHost(multiSelect) {
        if (!this.selectionManager) {
            return;
        }
        if (this.selectedIds && this.selectedIds.length) {
            this.selectionManager.select([...this.selectedIds], multiSelect);
        }
        else {
            this.selectionManager.clear();
        }
    }
    takeSelectionStateFromDataPoints(dataPoints) {
        const selectedIds = this.selectedIds;
        // Replace the existing selectedIds rather than merging.
        arrayExtensions.clear(selectedIds);
        for (const dataPoint of dataPoints) {
            if (dataPoint.selected) {
                selectedIds.push(dataPoint.identity);
            }
        }
    }
    applyToAllSelectableDataPoints(action) {
        const selectableDataPoints = this.selectableDataPoints;
        const selectableLegendDataPoints = this.selectableLegendDataPoints;
        const selectableLabelsDataPoints = this.selectableLabelsDataPoints;
        if (selectableDataPoints) {
            for (const dataPoint of selectableDataPoints) {
                action(dataPoint);
            }
        }
        if (selectableLegendDataPoints) {
            for (const dataPoint of selectableLegendDataPoints) {
                action(dataPoint);
            }
        }
        if (selectableLabelsDataPoints) {
            for (const dataPoint of selectableLabelsDataPoints) {
                action(dataPoint);
            }
        }
    }
    static updateSelectableDataPointsBySelectedIds(selectableDataPoints, selectedIds) {
        let foundMatchingId = false;
        for (const dataPoint of selectableDataPoints) {
            dataPoint.selected = checkDatapointAgainstSelectedIds(dataPoint, selectedIds);
            if (dataPoint.selected)
                foundMatchingId = true;
        }
        return foundMatchingId;
    }
    removeSelectionIdsWithOnlyMeasures() {
        this.selectedIds = this.selectedIds.filter((identity) => identity.hasIdentity());
    }
    removeSelectionIdsExceptOnlyMeasures() {
        this.selectedIds = this.selectedIds.filter((identity) => !identity.hasIdentity());
    }
}
//# sourceMappingURL=interactivityService.js.map